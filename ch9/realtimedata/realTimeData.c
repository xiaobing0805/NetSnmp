/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "realTimeData.h"
#include "realTimeData_checkfns.h"
#include "realTimeData_access.h"

static netsnmp_oid_stash_node *undoStorage = NULL;
static netsnmp_oid_stash_node *commitStorage = NULL;

struct undoInfo {
    void           *ptr;
    size_t          len;
};

struct commitInfo {
    void           *data_context;
    int             have_committed;
    int             new_row;
};

void
realTimeData_free_undoInfo(void *vptr)
{
    struct undoInfo *ui = vptr;
    if (!ui)
        return;
    SNMP_FREE(ui->ptr);
    SNMP_FREE(ui);
}



/* 将标量realTimeDataZ部分的代码拷贝到表格生成的文件中,
并将初始化的函数放入到模块注册函数中。
同时将函数名中含有 realTimeData 更改为 realTimeDataZ
*/
oid             realTimeData_variables_oid[] =    
	{ 1, 3, 6, 1, 4, 1, 8072, 9999, 9999, 1, 1 };

struct variable4 realTimeData_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */
#define REALTIMEDATAZ		1
    {REALTIMEDATAZ, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_realTimeDataZ, 1, {2}},
};


/* 拷贝并重命名: init_realTimeData -- >init_realTimeDataZ
* 所有的标量都可以统一处理
*/
void
init_realTimeDataZ(void)
{

	// realTimeData --> realTimeDataZ
    DEBUGMSGTL(("realTimeDataZ", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
     // realTimeData --> realTimeDataZ
    REGISTER_MIB("realTimeDataZ", realTimeData_variables, variable4,
                 realTimeData_variables_oid);
    /*
     * place any other initialization junk you need here 
     */
}

unsigned char  *
var_realTimeDataZ(struct variable *vp,
                 oid * name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod ** write_method)
{
	static u_char VAR[MAX_CHAR_LEN]={0};
    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case REALTIMEDATAZ:
		*var_len = sizeof(int); // 统一使用了u_char VAR
         snmp_get_data(SHM_REALDATA,4,sizeof(long),VAR); 
		 return (u_char *) &VAR;
    default:
        ERROR_MSG("NO THIS MAGIC!!");
    }
    return NULL;
}



/** Initialize the realTimeDataTable table by defining its contents and how it's structured */
void
initialize_table_realTimeDataTable(void)
{
    const oid       realTimeDataTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 8072, 9999, 9999, 1, 1, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    DEBUGMSGTL(("realTimeData:init",
                "initializing table realTimeDataTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("realTimeDataTable",
                                                     realTimeDataTable_handler,
                                                     realTimeDataTable_oid,
                                                     OID_LENGTH
                                                     (realTimeDataTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_realTimeDataTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,
                                               /** index: realTimeDataIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = 1;
    table_info->max_column = 3;

    /** iterator access routines */
    iinfo->get_first_data_point = realTimeDataTable_get_first_data_point;
    iinfo->get_next_data_point = realTimeDataTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = realTimeDataTable_context_convert_function;
    iinfo->free_data_context = realTimeDataTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = realTimeDataTable_loop_free;
    iinfo->free_loop_context_at_end = realTimeDataTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_realTimeDataTable",
                "Registering table realTimeDataTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initializes the realTimeData module */
void
init_realTimeData(void)
{

  /** here we initialize all the tables we're planning on supporting */
    initialize_table_realTimeDataTable();

  // 其他初始化的内容
  // 将变量部分的初始化
    init_realTimeDataZ(); 
  // 表格结构初始化
    init_table_realtime_data();
}




/** handles requests for the realTimeDataTable table, if anything else needs to be done */
int
realTimeDataTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    struct commitInfo *ci = NULL;

    void           *data_context = NULL;

    /** column and row index encoded portion */
    const oid      *const suffix =
        requests->requestvb->name + reginfo->rootoid_len + 1;
    const size_t    suffix_len = requests->requestvb->name_length -
        (reginfo->rootoid_len + 1);

    DEBUGMSGTL(("realTimeData:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if (data_context == NULL) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_REALTIMEDATAINDEX:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval =
                        get_realTimeDataIndex(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 retval, retval_len);
                }
                break;

            case COLUMN_REALTIMEDATAX1:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval = get_realTimeDataX1(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 retval, retval_len);
                }
                break;

            case COLUMN_REALTIMEDATAY2:
                {
                    long           *retval;
                    size_t          retval_len = 0;
                    retval = get_realTimeDataY2(data_context, &retval_len);
                    if (retval)
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 retval, retval_len);
                }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in realTimeDataTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in realTimeDataTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

