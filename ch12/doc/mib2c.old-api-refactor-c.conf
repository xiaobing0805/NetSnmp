######################################################################
## Do the .c file
######################################################################
@eval $date=scalar localtime; @
@open ${name}.c@
/*
 * Note: this file originally auto-generated by mib2c using
 * mib2c.old-api-refactor.conf $date
 * zhangchunqiang 2014-10
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "${name}.h"

/* other module head file please */

/* 
 * ${name}_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid ${name}_variables_oid[] = { $name.commaoid };

#define $name.uc_FATHERNODE_LENTH    (sizeof(${name}_variables_oid) / sizeof(oid) )


/* 
 * variable4 ${name}_variables:
 *   this variable defines function callbacks and type return information 
 *   for the $name mib section 
 */
struct variable4 ${name}_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
@eval $namelen = length("$name.commaoid")@
@foreach $i scalar@
    @eval $suffix = substr("$i.commaoid", $namelen + 1)@
    @eval $suffixlen = $i.oidlength - $name.oidlength@
    @if $i.settable@
{$i.uc,  $i.type,  NETSNMP_OLDAPI_RWRITE,  var_${name}, $suffixlen,  { $suffix }},
    @end@
    @if !$i.settable@
{$i.uc,  $i.type,  NETSNMP_OLDAPI_RONLY ,  var_${name}, $suffixlen,  { $suffix }},
    @end@
@end@

@foreach $i table@
 @eval $suffix = substr("$i.commaoid", $namelen + 1)@
 @eval $suffixlen = $i.oidlength - $name.oidlength + 2@
 @foreach $c column@
    @if $c.settable@
{$c.uc,  $c.type,  NETSNMP_OLDAPI_RWRITE,  var_${i}, $suffixlen,  { $suffix, 1, $c.subid }},
    @end@
    @if !$c.settable@
{$c.uc,  $c.type,  NETSNMP_OLDAPI_RONLY,   var_${i}, $suffixlen,  { $suffix, 1, $c.subid }},
    @end@
 @end@
@end@
{0,0,0,NULL,0,0} //added for find only
};

/*******************************************************
   通过oid查找magic
 ********************************************************/
static int find_magic_$name(const oid *name,int namelen)
{
 	return 
 		find_magic(name,namelen,
 		     $name.uc_FATHERNODE_LENTH, ${name}_variables);
}
/* 
*the int Num you may used in initialization
*and the '0' you may need replace with right data;
*NOTICE: this Num may not need sometimes,eg,they are from other module
*or they maybe as the globle data so please copy to the ${name}.h
*/
@foreach $i table@
int gi_${i}Num = 0; /* TODO */
@end@

/* 
*the gp_xxxHead is the list head you should initialize
*and use in the iteratoration to find the right node data.
*/
@foreach $i table@
T_TableSimple  *gp_${i}Head = NULL;
@end@

/* 
* for all scalar node :tacheID define
* that is your business now:
* fill it with your No.
* and check the MAGICs
*/
static  MIBIDSTRUCT  gt_${name}ScalarIDMap[]  ={
  /*No.,  MAGIC ,ASN_TYPE*/
@foreach $i scalar@
  {.t_tacheID.ipcNo = -1/*TODO*/,.t_tacheID.snmpmagic = $i.uc,.asnType=$i.type},
@end@ ##foreach $i scalar
};

#define SCALAR_$name.uc_NUM  (sizeof(gt_${name}ScalarIDMap) /sizeof(MIBIDSTRUCT))

/*
* check the table index need or not !!
* for table object :tacheID define
* that is your business now:
* fill it with your No.
* and check the MAGICs
*/
@foreach $i table@
static MIBIDSTRUCT gt_${i}IDMap[] = {
 @foreach $c column@
    {.t_tacheID.ipcNo = -1/*TODO*/,.t_tacheID.snmpmagic = $c.uc,.asnType=$c.type},
 @end@ ##foreach $c column
};
#define $i.uc_COLNUM  (sizeof(gt_${i}IDMap) /sizeof(MIBIDSTRUCT))

/*******************************************************
   通过行号和magic返回对应的节点
 ********************************************************/
static MIBIDSTRUCT  *
get_table_node_${i}( const oid *name,int name_len)
{

	// 首先，搜索请求节点的magic
	int magic = find_magic_$name(name,name_len);

	return
	    get_table_node(gp_${i}Head,
	                  $i.uc_COLNUM,name[name_len - 1],
	                  magic );
}

/*******************************************************
   通过行号和magic返回对应的节点
 ********************************************************/
static MIBIDSTRUCT  *
get_table_node_${i}_withmagic( int rowIndex,int magic )
{
	return
	    get_table_node(gp_${i}Head,
	                  $i.uc_COLNUM,rowIndex,
	                  magic );
}

/*******************************************************
   检查行索引是否越界
 ********************************************************/
static int check_row_index_${i}(int index)
{
	if( (index-1) > gi_${i}Num)
		return FAILURE;
	return SUCCESS;
}
@end@


 /*table initial*/
void init_table_${name}(void)
{
  @foreach $i table@
  init_nonindex_table(&gp_${i}Head, gt_${i}IDMap, 
                    $i.uc_COLNUM,gi_${i}Num);
  @end@
/*initialize other table that can not initialize by init_noIndexTable*/
}

/** Initializes the $name module */
void
init_$name(void)
{
    DEBUGMSGTL(("$name", "Initializing\n"));
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("$name", ${name}_variables, variable4,
               ${name}_variables_oid);

    /* place any other initialization junk you need here */
	init_shm_sem_slave( );
	init_table_${name}();
}

/*******************************************************
   通过magic找到对应的参数类数据节点
 ********************************************************/
static MIBIDSTRUCT  *get_${name}_scalar_obj(int magic)
{
	return
	    get_scalar_object(gt_${name}ScalarIDMap,
	                      SCALAR_$name.uc_NUM, magic);
}

/*******************************************************
   函数返回值的字节长度；通过序号找到对应的值
 ********************************************************/
static int snmp_get_data_${name}(MIBIDSTRUCT *pN,void *pV)
{
	if( NULL != pN && NULL != pV)
		if( snmp_get_data(SHM_$name.uc,pN->t_tacheID.ipcNo,MAX_CHAR_LEN,pV) >0 )
			return get_data_length( pN,pV );
	return 0;
}


/*******************************************************
   通过OID返回节点和返回对应的节点ASN类型
 ********************************************************/
static MIBIDSTRUCT *
get_scalar_node_${name}(const oid *name,int namelen)
{
	return
	    get_scalar_node(name,namelen,
	                        $name.uc_FATHERNODE_LENTH,
	                        ${name}_variables,
	                        gt_${name}ScalarIDMap,
	                        SCALAR_$name.uc_NUM);
}


/*******************************************************
   写标量和表格对象
 ********************************************************/
static int snmp_write_action_$name(int action, u_char snmpType,
                      int var_val_len, u_char * var_val,
                      const MIBIDSTRUCT  *writeNode)
{
	return 
		snmp_write_action(action, snmpType,
	                      var_val_len, var_val,writeNode,SHM_$name.uc);

}

/*
 * var_$name():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_$name(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
	static u_char VAR[MAX_CHAR_LEN]={0};
	MIBIDSTRUCT      *p_getNode = NULL;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;
		
	/* 我们替换掉switch结构
	   首先，根据magic查找请求的节点*/
	p_getNode = get_${name}_scalar_obj(vp->magic);
			
	/* 如果对象可写，则赋值设置函数 */
	if(vp->acl == NETSNMP_OLDAPI_RWRITE)
		*write_method = write_${name}_scalar;

	/*  最后返回获取的数据 */
	*var_len = snmp_get_data_${name}(p_getNode,VAR) ;	
	DEBUGMSG(("parameter"," --No.=%d,len=%d\n ",p_getNode->t_tacheID.ipcNo,*var_len));
	 if( *var_len > 0 )
		return VAR;
	return NULL;
}				


/*******************************************************
   简化写操作:找到指定的节点，执行设置操作
********************************************************/
int write_${name}_scalar(int action,
               u_char * var_val,
               u_char var_val_type,
               size_t var_val_len,
               u_char * statP, oid * name, size_t name_len)
{

    MIBIDSTRUCT       *p_writeNode = NULL;

   if(action == RESERVE1 || action == ACTION || action == COMMIT)   //reduce execute times
    {	
	// 首先，搜索指定的节点
		p_writeNode = get_scalar_node_${name}(name,name_len);
							   
	// 如果没有找到任何节点，返回错误标识
		if(p_writeNode == NULL)
		{
			DEBUGMSG(("parameter"," \n--in write_${name}_scalar,return NULL node !!\n "));
			return SNMP_ERR_WRONGENCODING;
		}
    }
	
	// 最后执行设置操作
	return
		snmp_write_action_parameter(action, var_val_type,
	                                var_val_len, var_val,p_writeNode);							  
}


@foreach $i table@
/*
 * var_$i():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_$name above.
 */
unsigned char *
var_$i(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
	static u_char VAR[MAX_CHAR_LEN]={0};
	MIBIDSTRUCT      *p_getNode = NULL;	

   /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the gi_${i}Num
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method,gi_${i}Num)
        == MATCH_FAILED)
    return NULL;

	if(FAILURE == check_row_index_${i}(name[*length - 1]))
		return NULL;
		
	DEBUGMSGTL(("parameter", "index = %d(%d)\n",index,vp->magic));
	/* 我们替换掉switch结构
	   首先，根据magic查找请求的节点*/
	p_getNode =
		 get_table_node_${i}_withmagic(name[*length - 1], vp->magic);				   
	/* 如果没有找到直接返回 */
	if(p_getNode == NULL) return NULL;	
	
	/* 如果对象可写，则赋值设置函数 */
	if(vp->acl == NETSNMP_OLDAPI_RWRITE)
		*write_method = write_${i}; // 每个表格统一使用一个写函数	
	
 	/*  最后返回获取的数据 */
	*var_len = snmp_get_data_${name}(p_getNode,VAR) ;
	DEBUGMSG(("parameter"," --No.=%d,len=%d\n ",p_getNode->t_tacheID.ipcNo,*var_len));
	 if( *var_len > 0 )
		return VAR;
	return NULL;
}

@if table_is_writable($i) eq 1@
int
write_$i(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
	MIBIDSTRUCT      *p_writeNode = NULL;
	static u_char type=0, magic =0;
	
    if(action == RESERVE1 || action == ACTION)             
    {  
		// 首先，搜索指定的节点
		p_writeNode = get_table_node_${i}( name,name_len);
		
		// 如果没有找到任何节点，返回错误标识
		if(p_writeNode == NULL)
			return SNMP_ERR_WRONGENCODING;			      
   }

   	// 最后执行设置操作
	return
		snmp_write_action_${name}(action, var_val_type,
	                                var_val_len, var_val,p_writeNode);
}
@end@  #end of if

@end@  #end of foreach

@quit@