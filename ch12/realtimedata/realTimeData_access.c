
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "realTimeData_access.h"
#include "realTimeData_enums.h"

T_TableIndex1  *gp_realTimeTableHead =NULL;

//MIBIDSTRUCT  *findTableNode(T_TableSimple *theRowHead,
//                         const unsigned int magic, int maxCol);


/** returns the first data point within the realTimeDataTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
realTimeDataTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    // 将表格结构传入到迭代器中，注意表格数据和迭代的索引都定义在该变量中
    *my_loop_context = gp_realTimeTableHead ;// 从loop_context中可以获取下一行数据
    *my_data_context = gp_realTimeTableHead ;// 从data_context中可以获取到表格数据
	
    // 设置表格索引:索引和索引字节长度(整型索引)
    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *)&(gp_realTimeTableHead->index) ,
                             sizeof(gp_realTimeTableHead->index) );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as realTimeDataTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
realTimeDataTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    //netsnmp_variable_list *vptr;

   // 获取迭代器中的用户数据
	T_TableIndex1  *temp =  (T_TableIndex1 *)*my_loop_context;
    T_TableIndex1  *nowData=NULL;

	if(temp->next == NULL)
    {
		*my_loop_context = NULL;
		*my_data_context = NULL ;
        DEBUGMSG(("realtimedata","--IN realData_single_get_next_data_point:RawHead = NULL\n"));
		return NULL;   
    }
	// 迭代器:控制如何获取下一个数据
    nowData =  temp->next;

    *my_loop_context = nowData;
    *my_data_context = nowData;

   // vptr = put_index_data;

	if( NULL != nowData )
    {
        DEBUGMSGTL(("realtimeData","--index =%d\n",nowData->index));
    	snmp_set_var_value(put_index_data, (u_char *)&(nowData->index) ,sizeof(nowData->index) );
	}
    //vptr = vptr->next_variable;

    return put_index_data;
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrieval and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void           *
realTimeDataTable_create_data_context(netsnmp_variable_list * index_data,
                                      int column)
{
    return NULL;                /* XXX: you likely want to return a real pointer */
}

/** If the implemented set_* functions don't operate directly on the
   real-live data (which is actually recommended), then this function
   can be used to take a given my_data_context pointer and "commit" it
   to whereever the modified data needs to be put back to.  For
   example, if this was a routing table you could publish the modified
   routes back into the kernel at this point.

   new_or_del will be set to 1 if new, or -1 if it should be deleted
   or 0 if it is just a modification of an existing row.

   If you free the data yourself, make sure to *my_data_context = NULL */
int
realTimeDataTable_commit_row(void **my_data_context, int new_or_del)
{
    /** Add any necessary commit code here */
    /*
     */

    /*
     * return no errors.  And there shouldn't be any!!!  Ever!!!  You
     * should have checked the values long before this. 
     */
    return SNMP_ERR_NOERROR;
}


/*
 * User-defined data access functions (per column) for data in table realTimeDataTable 
 */
/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */
/** XXX: return a data pointer to the data for the realTimeDataIndex column and set
         ret_len to its proper size in bytes. */

// 一般表格索引没有必要支持获取的权限-可以不实现-在定义时可定义为
// 不可获得
long           *
get_realTimeDataIndex(void *data_context, size_t *ret_len)
{

	// 获取迭代器中的用户数据
	 T_TableIndex1	*myData =  (T_TableIndex1 *)data_context;
     if(NULL == myData)	return NULL;  

	 *ret_len = sizeof(myData->index);
	 return (long *)&(myData->index);
}

/** XXX: return a data pointer to the data for the realTimeDataX1 column and set
         ret_len to its proper size in bytes. */
         
// data_context字面意思为数据上下文，也就是迭代器中返回的行         
long           *
get_realTimeDataX1(void *data_context, size_t *ret_len)
{
	 static long xx;
	 int no = 0;
	 MIBIDSTRUCT  *findedNode = NULL;
	 
	 // 获取迭代器中的用户数据
	 T_TableIndex1	*myData =  (T_TableIndex1 *)data_context;
	 findedNode = findTableNode(myData->list_node,COLUMN_REALTIMEDATAX1,
	 				COLUMN_REALTIMEDATA_MAX);
	 if(findedNode == NULL)        return NULL;
	 
	 no = findedNode->t_tacheID.ipcNo;
	 DEBUGMSG(("realtimedata","--get_realTimeDataX1 = %d\n",no));
	 
	 snmp_get_data(SHM_REALDATA,no,sizeof(long),&xx); 
	 *ret_len = sizeof(xx);
	 return  &xx;

}

/** XXX: return a data pointer to the data for the realTimeDataY2 column and set
         ret_len to its proper size in bytes. */
long           *
get_realTimeDataY2(void *data_context, size_t *ret_len)
{
	static long yy;
	int no = 0;
	MIBIDSTRUCT  *findedNode = NULL;
	
	// 获取迭代器中的用户数据
	T_TableIndex1  *myData =  (T_TableIndex1 *)data_context;
	findedNode = findTableNode(myData->list_node,COLUMN_REALTIMEDATAY2,
				   COLUMN_REALTIMEDATA_MAX);
	if(findedNode == NULL)		  return NULL;
	
	no = findedNode->t_tacheID.ipcNo;
	DEBUGMSG(("realtimedata","get_realTimeDataY2 = %d\n",no));
	
	snmp_get_data(SHM_REALDATA,no,sizeof(long),&yy); 
	*ret_len = sizeof(yy);
	return	&yy;
}


/* 
下面的定义只为了演示目的，实际情况，
 我们往往会引入另外的全局的标志.
 序号	magic 
*/
static T_SNMPMapTable gt_realTimeTableIDMap[] = {
  {XY0X, COLUMN_REALTIMEDATAX1}, {XY0Y, COLUMN_REALTIMEDATAY2}, 
 // {XY1X, COLUMN_REALTIMEDATAX1}, {XY1Y, COLUMN_REALTIMEDATAY2}, 
};
#define COLUMN_REALTIMEDATATABLE_MAX (  sizeof(gt_realTimeTableIDMap) / sizeof(T_SNMPMapTable)  )

void init_table_realtime_data(void)
{
       // 初始化两行两列的实时数据
	   init_singleIndexTable( &gp_realTimeTableHead,
             gt_realTimeTableIDMap,COLUMN_REALTIMEDATA_MAX, 
         GROUP_NUM,0 );
	   // 其他初始化的内容
}




